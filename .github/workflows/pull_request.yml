# --- START OF FILE .github/workflows/pull_request.yml (FINAL v2.5 - DEFINITIVELY COMPLETE) ---
name: PR CI (CPU-only, fast, deterministic)

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]

concurrency:
  group: pr-ci-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

jobs:
  lint:
    name: üßπ Lint / Format (changed files only)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Fetch full history to ensure git diff has a valid base to compare against
          fetch-depth: 0

      - name: Install clang-format
        run: |
          sudo apt-get update
          sudo apt-get install -y clang-format-14

      - name: Check formatting (diff-only)
        run: |
          # Define the base for comparison (the branch the PR is targeting)
          BASE_REF="origin/${{ github.base_ref || 'main' }}"
          
          echo "Comparing current branch against '${BASE_REF}'..."

          # Use a robust while-read loop to process filenames safely
          # This avoids issues with spaces or special characters in filenames
          git diff --name-only "${BASE_REF}" | grep -E '\.(c|cc|cpp|cxx|cu|cuh|h|hh|hpp)$' | while IFS= read -r file;
          do
            if [ -f "$file" ]; then
              echo "Checking: ${file}"
              # Run clang-format on each file individually
              clang-format-14 -style=file --dry-run --Werror "${file}"
            else
              echo "Skipping deleted file: ${file}"
            fi
          done

          # Check the exit status of the git diff/grep pipeline.
          # PIPESTATUS[0] is for git diff, PIPESTATUS[1] is for grep.
          # If grep finds no matching files, its exit code is 1, which is not an error here.
          # We only fail if clang-format itself failed (which it does via --Werror).
          if [ ${PIPESTATUS[0]} -ne 0 ]; then
             echo "Error during git diff."
             exit 1
          fi
          
          echo "‚úÖ All changed C++ files are correctly formatted."

  build-cpu:
    name: üõ†Ô∏è Build (CPU-only, manylinux_2_28)
    runs-on: ubuntu-latest
    needs: lint
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Build CPU container
        run: docker build -f Dockerfile.cpu -t helios-embed-cpu-builder .
      
      - name: Verify CPU-only Environment before Build
        run: |
          docker run --rm -v "$(pwd)":/io helios-embed-cpu-builder \
            python - <<'PY'
          import os, shutil, torch
          print("--- Verifying Environment ---")
          print("torch.__version__         =", torch.__version__)
          print("torch.version.cuda        =", getattr(torch.version, "cuda", None))
          print("torch.cuda.is_available() =", torch.cuda.is_available())
          print("which nvcc                =", shutil.which("nvcc"))
          PY

      - name: Build project inside container (smoke test)
        run: |
          # The pip install -e . in the Dockerfile already handles the build.
          # This step just verifies the final image works by importing the module.
          docker run --rm -v "$(pwd)":/io helios-embed-cpu-builder \
            bash -lc "python -c 'import helios_embed; print(\"Module import successful inside container.\")'"

  test-cpu:
    name: ‚úÖ Tests (short, CPU-only)
    runs-on: ubuntu-latest
    needs: build-cpu
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Build CPU container (re-use from cache if available)
        run: docker build -f Dockerfile.cpu -t helios-embed-cpu-builder .

      - name: Run short tests (GPU-free)
        run: |
          docker run --rm -v "$(pwd)":/io helios-embed-cpu-builder \
            bash -lc "python run_tests.py"

  static-analysis:
    name: üî¨ Static Analysis (advisory)
    runs-on: ubuntu-latest
    needs: test-cpu
    continue-on-error: true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install clang-tidy
        run: |
          sudo apt-get update
          sudo apt-get install -y clang-tidy-14

      - name: Run clang-tidy on changed files (bounded)
        run: |
          BASE_REF="origin/${{ github.base_ref || 'main' }}"
          git diff --name-only "${BASE_REF}" | grep -E '\.(c|cc|cpp|cxx|cu|cuh|h|hh|hpp)$' | while IFS= read -r file;
          do
            if [ -f "$file" ]; then
              echo "Analyzing $f"
              # A compile_commands.json file is the most robust way to provide includes.
              # This is a best-effort check for a simple project structure.
              clang-tidy-14 "$f" -- -std=c++17 -I src/helios_embed -I $(python -c 'import torch; print(torch.utils.cpp_extension.include_paths()[0])') -I $(python -c 'import pybind11; print(pybind11.get_include())') || true
            fi
          done
# --- END OF FILE .github/workflows/pull_request.yml (FINAL v2.5 - DEFINITIVELY COMPLETE) ---